---
title: "Automated Versioning"
subtitle: "Series - Path Carver"
date: "2025-12-17T07:00:00.000Z"
author: "Elijah Samuels"
---


#### What

This tip is about automating the versioning of a repo because manually keeping track of that is asking for mistakes. 

#### Why

A couple important reasons to updating the version of a project include:
1. if your project is a dependency, then allowing the host to select which version,
2. [semantically indicating the changes between your versions](https://semver.org/) and
3. providing a clear version in logs/monitoring.

I personally also find #3 really helpful when rapidly deploying changes and I need to make sure the deployment is on the correct version before triggering anything. As an engineer digging through logs, I want to be able to see any log entry, even if it's only the projects initialization, and be able to tell what version of the software I'm looking at.

#1 and #2 are also very important, and arguably required, especially if your project is a dependency for another project.

#### How

In this project, I'm using React for the frontend, Node for the backed, Postgresql for the database, Gitlab for CI/CD with terraform and AWS for the infrastructure.

1. Generate the Access Token. In the repo, go to Settings > Access Tokens > Click "Add new token". Name it something obvious, like "semantic-release-token" and give it a role of "Maintainer" with Scopes `api` and `write_repository`, and click `Create project access token`. Copy this token for step 2.

2. Add the token to the CI/CD Variable (Settings > CI/CD > Variables). Click Add variable, and set the key to `GITLAB_TOKEN`. (This is the standard environment variable semantic-release uses for GitLab).

Set the Value to the token you copied.
Double check protect variable is checked if your release branch is protected and mask variable is checked. Click "Add variable".

3. Install these:

```bash
npm install --save-dev semantic-release @semantic-release/gitlab @semantic-release/git @semantic-release/changelog @semantic-release/commit-analyzer @semantic-release/release-notes-generator
```

4. Add this job to your gitlab-ci.yml file. This presumes you already have a build stage, and in this example below, the a job `build_frontend` will successfully complete before running this one.

```yml
semantic_release:
  stage: build # update this to match your build stage name
  image: node:lts
  only:
    - main
  before_script:
    - npm ci --legacy-peer-deps
    # Git setup to allow semantic-release to push back to the repository
    - git config user.email "ci-bot@example.com"
    - git config user.name "GitLab CI Bot"
  script:
    - npx semantic-release
  needs:
    - job: build_frontend # update this to match your build job name
```

5. Create a new file `.releaserc.json` in the root directory of your project and add this:

```json
{
  "branches": [
    "main"
  ],
  "plugins": [
    "@semantic-release/commit-analyzer",
    "@semantic-release/release-notes-generator",
    "@semantic-release/changelog",
    [
      "@semantic-release/npm",
      {
        "npmPublish": false,
        "prepareCmd": ""
      }
    ],
    "@semantic-release/gitlab",
    [
      "@semantic-release/git",
      {
        "assets": [
          "CHANGELOG.md",
          "package.json"
        ],
        "message": "chore(release): ${nextRelease.version} [skip ci]\n\n${nextRelease.notes}"
      }
    ]
  ]
}
```








This is is part of an series of tricks I've picked up while building a project with a good friend, Matty. We connected during our Flatiron School bootcamp, and have stayed in touch since. 
